import fxpmath as fxp
import os 


table = [
     (0.004,  -0.98, -4.000 , -3.1111),
     (0.02,  - 0.93, -3.1111 , -2.2222),
     (0.12,  - 0.71, -2.2222 , -1.3333),
     (0.51,  - 0.19, -1.3333 , -0.444444),
     (0.94, 0, - 0.44444 , 0.44444),
     (0.51,   0.19, 0.44444 , 1.3333),
     (0.12,   0.71, 1.3333 , 2.2222),
     (0.02,   0.93, 2.2222 , 3.1111),
     (0.004,   0.98, 3.1111 , 4.000) 
]

fxp_size = 32
fxp_frac = 12

def tofxp(x, frac_delta = 0):
     return fxp.Fxp(x, signed=True, n_word=fxp_size, n_frac=fxp_frac + frac_delta).bin()

module = f'''
// autogenerated 

// fxp_size = {fxp_size}
// fxp_frac = {fxp_frac}

module pwl_tanh(
     input clk,
     input rst,
     input  signed[{fxp_size}-1:  0] i_x,
     output signed[{fxp_size}-1:  0] o_res
);

     localparam fxp_size = {fxp_size};
     localparam fxp_frac = {fxp_frac};

     localparam neg_inf = {fxp_size}'b{tofxp(-1)} + {fxp_size}'d1; // errors
     localparam pls_inf = {fxp_size}'b{tofxp(1)} - {fxp_size}'d1; // errors

     logic signed[{fxp_size}-1:     0] result;
     logic signed[{fxp_size}-1:     0] clamped_result;
     assign o_res = result;
     assign clamped_result = (i_x & ({fxp_size}'b1 << {fxp_size-1}))? neg_inf : pls_inf;

     logic[10: 0] deb;
'''

for i in range(len(table)):
     a, b, l, r = map(tofxp, table[i])
     module += f'''
     localparam a_{i} = $signed({fxp_size}'b{a});
     localparam b_{i} = $signed({fxp_size}'b{b});
     localparam l_{i} = $signed({fxp_size}'b{l});
     localparam r_{i} = $signed({fxp_size}'b{r});
'''

module += '\n'*3

for i in range(len(table)):
     module += f'''
     wire[{fxp_size}-1:    0] prod_{i}_next;
     logic[{fxp_size}-1:    0] prod_{i};
     fixed_multiply#(
          .fractional_size({fxp_frac}),
          .operand_size({fxp_size}),
          .expansion_size(0)
     ) ins_mul_{i} (
          .i_a(i_x),
          .i_b(a_{i}),
          .o_res(prod_{i}_next)
     );

     always_ff @(posedge clk) begin
          if(rst)
               prod_{i} <= '0;
          else
               prod_{i} <= prod_{i}_next;
     end
''' 
     
module += '''
     always_comb begin
'''
for i in range(len(table)):
     if i == 0:if_st = 'if'
     else:     if_st = 'else if'

     module += f'''
          {if_st}(l_{i} <= i_x && i_x < r_{i}) begin
               result = prod_{i} + b_{i};
               // deb = {i};
          end
     '''

module += f'''
          else begin // out of bounds 
               result = clamped_result;
               // deb = (i_x & ({fxp_size}'b1 << {fxp_size-1}))? 90: 100;
          end
'''

module += '''
     end
endmodule
'''

path = os.path.dirname(os.path.realpath(__file__)) # tanh
path = os.path.dirname(path) # util
path = os.path.dirname(path) # project
path = os.path.join(path, "rtl/generated/pwl_tanh.sv")
open(path, 'w').write(module)
print('Wrote', len(module), 'b')